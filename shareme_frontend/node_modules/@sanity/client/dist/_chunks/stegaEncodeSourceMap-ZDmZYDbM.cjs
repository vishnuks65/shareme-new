'use strict';

var nodeMiddleware = require('./nodeMiddleware-Gh18jsRe.cjs');
var resolveEditInfo = require('./resolveEditInfo-dELeeJBE.cjs');

function encodeIntoResult(result, csm, encoder) {
  return resolveEditInfo.walkMap(result, (value, path) => {
    if (typeof value !== "string") {
      return value;
    }
    const resolveMappingResult = resolveEditInfo.resolveMapping(path, csm);
    if (!resolveMappingResult) {
      return value;
    }
    const { mapping, matchedPath } = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument = csm.documents[mapping.source.document];
    const sourcePath = csm.paths[mapping.source.path];
    const matchPathSegments = resolveEditInfo.parseJsonPath(matchedPath);
    const sourcePathSegments = resolveEditInfo.parseJsonPath(sourcePath);
    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));
    return encoder({
      sourcePath: fullSourceSegments,
      sourceDocument,
      resultPath: path,
      value
    });
  });
}

const filterDefault = ({ sourcePath, value }) => {
  if (isValidDate(value) || isValidURL(value)) {
    return false;
  }
  const endPath = sourcePath.at(-1);
  if (sourcePath.at(-2) === "slug" && endPath === "current") {
    return false;
  }
  if (typeof endPath === "string" && endPath.startsWith("_")) {
    return false;
  }
  if (typeof endPath === "number" && sourcePath.at(-2) === "marks") {
    return false;
  }
  if (endPath === "href" && typeof sourcePath.at(-2) === "number" && sourcePath.at(-3) === "markDefs") {
    return false;
  }
  if (endPath === "style" || endPath === "listItem") {
    return false;
  }
  if (sourcePath.some(
    (path) => path === "meta" || path === "metadata" || path === "openGraph" || path === "seo"
  )) {
    return false;
  }
  if (typeof endPath === "string" && denylist.has(endPath)) {
    return false;
  }
  return true;
};
const denylist = /* @__PURE__ */ new Set([
  "color",
  "colour",
  "currency",
  "email",
  "format",
  "gid",
  "hex",
  "href",
  "hsl",
  "hsla",
  "icon",
  "id",
  "index",
  "key",
  "language",
  "layout",
  "link",
  "linkAction",
  "locale",
  "lqip",
  "page",
  "path",
  "ref",
  "rgb",
  "rgba",
  "route",
  "secret",
  "slug",
  "status",
  "tag",
  "template",
  "theme",
  "type",
  "unit",
  "url",
  "username",
  "variant",
  "website"
]);
function isValidDate(dateString) {
  return /^\d{4}-\d{2}-\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false;
}
function isValidURL(url) {
  try {
    new URL(url, url.startsWith("/") ? "https://acme.com" : void 0);
  } catch {
    return false;
  }
  return true;
}

const TRUNCATE_LENGTH = 20;
function stegaEncodeSourceMap(result, resultSourceMap, config) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const { filter, logger, enabled } = config;
  if (!enabled) {
    const msg = "config.enabled must be true, don't call this function otherwise";
    (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/client/stega]: ".concat(msg), { result, resultSourceMap, config });
    throw new TypeError(msg);
  }
  if (!resultSourceMap) {
    (_b = logger == null ? void 0 : logger.error) == null ? void 0 : _b.call(logger, "[@sanity/client/stega]: Missing Content Source Map from response body", {
      result,
      resultSourceMap,
      config
    });
    return result;
  }
  if (!config.studioUrl) {
    const msg = "config.studioUrl must be defined";
    (_c = logger == null ? void 0 : logger.error) == null ? void 0 : _c.call(logger, "[@sanity/client/stega]: ".concat(msg), { result, resultSourceMap, config });
    throw new TypeError(msg);
  }
  const report = {
    encoded: [],
    skipped: []
  };
  const resultWithStega = encodeIntoResult(
    result,
    resultSourceMap,
    ({ sourcePath, sourceDocument, resultPath, value }) => {
      if ((typeof filter === "function" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === false) {
        if (logger) {
          report.skipped.push({
            path: prettyPathForLogging(sourcePath),
            value: "".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? "..." : ""),
            length: value.length
          });
        }
        return value;
      }
      if (logger) {
        report.encoded.push({
          path: prettyPathForLogging(sourcePath),
          value: "".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? "..." : ""),
          length: value.length
        });
      }
      const { baseUrl, workspace, tool } = resolveEditInfo.resolveStudioBaseRoute(
        typeof config.studioUrl === "function" ? config.studioUrl(sourceDocument) : config.studioUrl
      );
      if (!baseUrl)
        return value;
      const { _id: id, _type: type } = sourceDocument;
      return nodeMiddleware.b(
        value,
        {
          origin: "sanity.io",
          href: resolveEditInfo.createEditUrl({
            baseUrl,
            workspace,
            tool,
            id,
            type,
            path: sourcePath
          })
        },
        // We use custom logic to determine if we should skip encoding
        false
      );
    }
  );
  if (logger) {
    const isSkipping = report.skipped.length;
    const isEncoding = report.encoded.length;
    if (isSkipping || isEncoding) {
      (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _d(
        "[@sanity/client/stega]: Encoding source map into result"
      );
      (_e = logger.log) == null ? void 0 : _e.call(
        logger,
        "[@sanity/client/stega]: Paths encoded: ".concat(report.encoded.length, ", skipped: ").concat(report.skipped.length)
      );
    }
    if (report.encoded.length > 0) {
      (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, "[@sanity/client/stega]: Table of encoded paths");
      (_g = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _g(report.encoded);
    }
    if (report.skipped.length > 0) {
      const skipped = /* @__PURE__ */ new Set();
      for (const { path } of report.skipped) {
        skipped.add(path.replace(resolveEditInfo.reKeySegment, "0").replace(/\[\d+\]/g, "[]"));
      }
      (_h = logger == null ? void 0 : logger.log) == null ? void 0 : _h.call(logger, "[@sanity/client/stega]: List of skipped paths", [...skipped.values()]);
    }
    if (isSkipping || isEncoding) {
      (_i = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _i.call(logger);
    }
  }
  return resultWithStega;
}
function prettyPathForLogging(path) {
  return resolveEditInfo.toString(resolveEditInfo.jsonPathToStudioPath(path));
}

var stegaEncodeSourceMap$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  stegaEncodeSourceMap: stegaEncodeSourceMap
});

exports.encodeIntoResult = encodeIntoResult;
exports.stegaEncodeSourceMap = stegaEncodeSourceMap;
exports.stegaEncodeSourceMap$1 = stegaEncodeSourceMap$1;
//# sourceMappingURL=stegaEncodeSourceMap-ZDmZYDbM.cjs.map
