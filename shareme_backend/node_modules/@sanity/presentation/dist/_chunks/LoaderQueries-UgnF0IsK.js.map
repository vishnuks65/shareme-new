{"version":3,"file":"LoaderQueries-UgnF0IsK.js","sources":["../../../visual-editing-helpers/dist/hooks.js","../../src/loader/LoaderQueries.tsx"],"sourcesContent":["import{useMemo as e,useState as n,useCallback as t,useEffect as i,useSyncExternalStore as r}from\"react\";function o(n){const t=e((()=>JSON.stringify(n||{})),[n]);return e((()=>JSON.parse(t)),[t])}function s(e){const{refreshInterval:o}=e,s=function(){const[e,t]=n(!1);i((()=>{t(navigator.onLine);const e=()=>t(!0),n=()=>t(!1);return window.addEventListener(\"online\",e),window.addEventListener(\"offline\",n),()=>{window.removeEventListener(\"online\",e),window.removeEventListener(\"offline\",n)}}),[]);const o=r(u,(()=>document.visibilityState),(()=>\"hidden\"));if(!e)return!0;if(\"hidden\"===o)return!0;return!1}(),[d,c]=n(\"hit\"),f=t((()=>(c(\"inflight\"),()=>c(\"hit\"))),[]);return i((()=>{if(!o||\"hit\"!==d)return;const e=setTimeout((()=>c(\"stale\")),o);return()=>clearTimeout(e)}),[o,d]),i((()=>{if(\"hit\"!==d)return;const e=()=>c(\"stale\");return window.addEventListener(\"focus\",e),()=>window.removeEventListener(\"focus\",e)}),[o,d]),i((()=>{s&&\"hit\"===d&&c(\"stale\"),s||\"stale\"!==d||c(\"refresh\")}),[s,d]),[d,f]}function u(e){return document.addEventListener(\"visibilitychange\",e),()=>document.removeEventListener(\"visibilitychange\",e)}export{o as useQueryParams,s as useRevalidate};//# sourceMappingURL=hooks.js.map\n","import type { ChannelsController } from '@sanity/channels'\nimport type {\n  ClientConfig,\n  ClientPerspective,\n  ContentSourceMap,\n  QueryParams,\n} from '@sanity/client'\nimport { applySourceDocuments, getPublishedId } from '@sanity/client/csm'\nimport type {\n  LoaderPayloads,\n  VisualEditingMsg,\n} from '@sanity/visual-editing-helpers'\nimport {\n  useQueryParams,\n  useRevalidate,\n} from '@sanity/visual-editing-helpers/hooks'\nimport { applyPatch } from 'mendoza'\nimport LRUCache from 'mnemonist/lru-cache-with-delete'\nimport { memo, useEffect, useMemo, useState } from 'react'\nimport { type SanityClient, type SanityDocument, useClient } from 'sanity'\n\nimport {\n  LIVE_QUERY_CACHE_BATCH_SIZE,\n  LIVE_QUERY_CACHE_SIZE,\n} from '../constants'\nimport type { LiveQueriesState } from '../types'\n\nexport interface LoaderQueriesProps {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  channel: ChannelsController<VisualEditingMsg> | undefined\n  perspective: ClientPerspective\n  liveQueries: LiveQueriesState\n  documentsOnPage: { _id: string; _type: string }[]\n}\n\nexport default function LoaderQueries(props: LoaderQueriesProps): JSX.Element {\n  const {\n    liveDocument,\n    channel,\n    perspective: activePerspective,\n    liveQueries,\n    documentsOnPage,\n  } = props\n  const [cache] = useState(\n    () => new LRUCache<string, SanityDocument>(LIVE_QUERY_CACHE_SIZE),\n  )\n  const studioClient = useClient({ apiVersion: '2023-10-16' })\n  const clientConfig = useMemo(() => studioClient.config(), [studioClient])\n  const client = useMemo(\n    () =>\n      studioClient.withConfig({\n        resultSourceMap: 'withKeyArraySelector',\n      }),\n    [studioClient],\n  )\n  useEffect(() => {\n    if (channel) {\n      const { projectId, dataset } = clientConfig\n      channel.send('loaders', 'loader/perspective', {\n        projectId: projectId!,\n        dataset: dataset!,\n        perspective: activePerspective,\n      } satisfies LoaderPayloads['perspective'])\n    }\n  }, [channel, clientConfig, activePerspective])\n\n  const turboIds = useMemo(() => {\n    const documentsActuallyInUse = documentsOnPage.map(({ _id }) => _id)\n    const set = new Set(documentsActuallyInUse)\n    const ids = [...set]\n    const max = cache.capacity\n    if (ids.length >= max) {\n      ids.length = max\n    }\n    return ids\n  }, [cache.capacity, documentsOnPage])\n\n  const [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = useState(0)\n\n  return (\n    <>\n      <Turbo\n        cache={cache}\n        client={client}\n        turboIds={turboIds}\n        setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n      />\n      {Object.entries(liveQueries).map(\n        ([key, { query, params, perspective }]) => (\n          <QuerySubscription\n            key={`${key}${perspective}`}\n            cache={cache}\n            projectId={clientConfig.projectId!}\n            dataset={clientConfig.dataset!}\n            perspective={perspective}\n            query={query}\n            params={params}\n            channel={channel}\n            client={client}\n            refreshInterval={activePerspective ? 2000 : 0}\n            liveDocument={liveDocument}\n            documentsCacheLastUpdated={documentsCacheLastUpdated}\n          />\n        ),\n      )}\n    </>\n  )\n}\n\ninterface SharedProps {\n  /**\n   * The Sanity client to use for fetching data and listening to mutations.\n   */\n  client: SanityClient\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   * @defaultValue 10000\n   */\n  refreshInterval?: number\n  /**\n   * The documents cache to use for turbo-charging queries.\n   */\n  cache: LRUCache<string, SanityDocument>\n}\n\ninterface TurboProps extends Pick<SharedProps, 'client' | 'cache'> {\n  turboIds: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const { cache, client, turboIds, setDocumentsCacheLastUpdated } = props\n  // Figure out which documents are missing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (!batchSet.has(turboId) && !cache.has(turboId)) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, LIVE_QUERY_CACHE_BATCH_SIZE)\n    if (nextBatchSlice.length === 0) return\n    setBatch((prevBatch) => [\n      ...prevBatch.slice(-LIVE_QUERY_CACHE_BATCH_SIZE),\n      nextBatchSlice,\n    ])\n  }, [batch, cache, turboIds])\n\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = client\n      .listen(\n        '*',\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'presentation-loader',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type === 'mutation' && update.transition === 'disappear') {\n          if (cache.delete(update.documentId)) {\n            setDocumentsCacheLastUpdated(Date.now())\n          }\n        }\n\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const cachedDocument = cache.peek(update.documentId)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = { ...cachedDocument } as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          cache.set(update.documentId, patchedDocument)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      })\n    return () => subscription.unsubscribe()\n  }, [cache, client, setDocumentsCacheLastUpdated])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          cache={cache}\n          client={client}\n          ids={ids}\n          setDocumentsCacheLastUpdated={setDocumentsCacheLastUpdated}\n        />\n      ))}\n    </>\n  )\n})\n\ninterface GetDocumentsProps extends Pick<SharedProps, 'client' | 'cache'> {\n  ids: string[]\n  setDocumentsCacheLastUpdated: (timestamp: number) => void\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const { client, cache, ids, setDocumentsCacheLastUpdated } = props\n\n  useEffect(() => {\n    const missingIds = ids.filter((id) => !cache.has(id))\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          cache.set(doc._id, doc)\n          setDocumentsCacheLastUpdated(Date.now())\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [cache, client, ids, setDocumentsCacheLastUpdated])\n\n  return null\n})\nGetDocuments.displayName = 'GetDocuments'\n\ninterface QuerySubscriptionProps\n  extends Pick<\n    UseQuerySubscriptionProps,\n    | 'client'\n    | 'cache'\n    | 'refreshInterval'\n    | 'liveDocument'\n    | 'documentsCacheLastUpdated'\n  > {\n  projectId: string\n  dataset: string\n  perspective: ClientPerspective\n  query: string\n  params: QueryParams\n  channel: ChannelsController<VisualEditingMsg> | undefined\n}\nfunction QuerySubscription(props: QuerySubscriptionProps) {\n  const {\n    cache,\n    projectId,\n    dataset,\n    perspective,\n    query,\n    client,\n    refreshInterval,\n    liveDocument,\n    channel,\n    documentsCacheLastUpdated,\n  } = props\n\n  const params = useQueryParams(props.params)\n  const data = useQuerySubscription({\n    cache,\n    client,\n    liveDocument,\n    params,\n    perspective,\n    query,\n    refreshInterval,\n    documentsCacheLastUpdated,\n  })\n  const result = data?.result\n  const resultSourceMap = data?.resultSourceMap\n\n  useEffect(() => {\n    if (resultSourceMap) {\n      channel!.send('loaders', 'loader/query-change', {\n        projectId,\n        dataset,\n        perspective,\n        query,\n        params,\n        result,\n        resultSourceMap,\n      } satisfies LoaderPayloads['query-change'])\n    }\n  }, [\n    channel,\n    dataset,\n    params,\n    perspective,\n    projectId,\n    query,\n    result,\n    resultSourceMap,\n  ])\n\n  return null\n}\n\ninterface UseQuerySubscriptionProps\n  extends Required<Pick<SharedProps, 'client' | 'refreshInterval' | 'cache'>> {\n  liveDocument: Partial<SanityDocument> | null | undefined\n  query: string\n  params: QueryParams\n  perspective: ClientPerspective\n  documentsCacheLastUpdated: number\n}\nfunction useQuerySubscription(props: UseQuerySubscriptionProps) {\n  const {\n    cache,\n    liveDocument,\n    client,\n    refreshInterval,\n    query,\n    params,\n    perspective,\n    documentsCacheLastUpdated,\n  } = props\n  const [snapshot, setSnapshot] = useState<{\n    result: unknown\n    resultSourceMap?: ContentSourceMap\n  } | null>(null)\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({ refreshInterval })\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    let fetching = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const { signal } = controller\n      fetching = true\n      const { result, resultSourceMap } = await client.fetch(query, params, {\n        tag: 'presentation-loader',\n        signal,\n        perspective,\n        filterResponse: false,\n      })\n      fetching = false\n\n      if (!signal.aborted) {\n        setSnapshot({ result, resultSourceMap })\n\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        fetching = false\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled && !fetching) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    liveDocument,\n    params,\n    perspective,\n    projectId,\n    query,\n    shouldRefetch,\n    startRefresh,\n  ])\n\n  return useMemo(() => {\n    if (documentsCacheLastUpdated && snapshot?.resultSourceMap) {\n      return {\n        result: turboChargeResultIfSourceMap(\n          cache,\n          liveDocument,\n          snapshot.result,\n          perspective,\n          snapshot.resultSourceMap,\n        ),\n        resultSourceMap: snapshot.resultSourceMap,\n      }\n    }\n    return snapshot\n  }, [cache, documentsCacheLastUpdated, liveDocument, perspective, snapshot])\n}\n\nlet warnedAboutCrossDatasetReference = false\nexport function turboChargeResultIfSourceMap<T = unknown>(\n  cache: SharedProps['cache'],\n  liveDocument: Partial<SanityDocument> | null | undefined,\n  result: T,\n  perspective: ClientPerspective,\n  resultSourceMap?: ContentSourceMap,\n): T {\n  if (perspective === 'raw') {\n    throw new Error(\n      'turboChargeResultIfSourceMap does not support raw perspective',\n    )\n  }\n  return applySourceDocuments(\n    result,\n    resultSourceMap,\n    (sourceDocument) => {\n      if (sourceDocument._projectId) {\n        // @TODO Handle cross dataset references\n        if (!warnedAboutCrossDatasetReference) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Cross dataset references are not supported yet, ignoring source document',\n            sourceDocument,\n          )\n          warnedAboutCrossDatasetReference = true\n        }\n        return undefined\n      }\n      // If there's a displayed document, always prefer it\n      if (\n        liveDocument?._id &&\n        getPublishedId(liveDocument._id) === getPublishedId(sourceDocument._id)\n      ) {\n        return liveDocument\n      }\n      // Fallback to general documents cache\n      return cache.get(sourceDocument._id)\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (changedValue: any, { previousValue }) => {\n      if (\n        typeof changedValue === 'number' &&\n        typeof previousValue === 'string'\n      ) {\n        // If the string() function was used in the query, we need to convert the source value to a string as well\n        return `${changedValue}`\n      }\n      return changedValue\n    },\n    perspective,\n  )\n}\n"],"names":["u","e","document","addEventListener","removeEventListener","LoaderQueries","props","liveDocument","channel","perspective","activePerspective","liveQueries","documentsOnPage","cache","useState","LRUCache","LIVE_QUERY_CACHE_SIZE","studioClient","useClient","apiVersion","clientConfig","useMemo","config","client","withConfig","resultSourceMap","useEffect","projectId","dataset","send","turboIds","documentsActuallyInUse","map","_id","ids","Set","max","capacity","length","documentsCacheLastUpdated","setDocumentsCacheLastUpdated","jsxs","Fragment","children","jsx","Turbo","Object","entries","key","query","params","QuerySubscription","refreshInterval","concat","memo","batch","setBatch","batchSet","flat","nextBatch","turboId","has","add","nextBatchSlice","slice","LIVE_QUERY_CACHE_BATCH_SIZE","prevBatch","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","tag","subscribe","update","_a","_b","type","transition","delete","documentId","Date","now","effects","apply","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","set","unsubscribe","GetDocuments","JSON","stringify","missingIds","filter","id","getDocuments","then","documents","doc","console","error","n","t","parse","useQueryParams","data","snapshot","setSnapshot","setError","revalidate","startRefresh","o","s","i","navigator","onLine","window","r","visibilityState","d","c","f","setTimeout","clearTimeout","useRevalidate","shouldRefetch","fulfilled","fetching","controller","AbortController","async","effect","signal","result","fetch","filterResponse","aborted","onFinally","catch","name","finally","abort","turboChargeResultIfSourceMap","useQuerySubscription","displayName","warnedAboutCrossDatasetReference","Error","applySourceDocuments","sourceDocument","_projectId","getPublishedId","get","warn","changedValue","previousValue"],"mappings":"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"}