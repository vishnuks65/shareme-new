{"ast":null,"code":"import { b } from './browserMiddleware-zDVeirri.js';\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  if (typeof segment === \"string\") {\n    return reKeySegment.test(segment.trim());\n  }\n  return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path)) {\n    throw new Error(\"Path is not an array\");\n  }\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    }\n    if (segmentType === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    if (isKeySegment(segment) && segment._key) {\n      return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n    }\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n    }\n    throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n};\nconst UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": \"\\n\",\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return \"$\".concat(path.map(segment => {\n    if (typeof segment === \"string\") {\n      const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, match => {\n        return ESCAPE[match];\n      });\n      return \"['\".concat(escapedKey, \"']\");\n    }\n    if (typeof segment === \"number\") {\n      return \"[\".concat(segment, \"]\");\n    }\n    if (segment._key !== \"\") {\n      const escapedKey = segment._key.replace(/['\\\\]/g, match => {\n        return ESCAPE[match];\n      });\n      return \"[?(@._key=='\".concat(escapedKey, \"')]\");\n    }\n    return \"[\".concat(segment._index, \"]\");\n  }).join(\"\"));\n}\nfunction parseJsonPath(path) {\n  const parsed = [];\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, m => {\n        return UNESCAPE[m];\n      });\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, m => {\n        return UNESCAPE[m];\n      });\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map(segment => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._key !== \"\") {\n      return {\n        _key: segment._key\n      };\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map(segment => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!(csm == null ? void 0 : csm.mappings)) {\n    return void 0;\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  }\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0) {\n    return void 0;\n  }\n  const [matchedPath, mapping] = mappings[0];\n  const pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return {\n    mapping,\n    matchedPath,\n    pathSuffix\n  };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value === \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v[\"_key\"];\n        if (typeof _key === \"string\") {\n          return walkMap(v, mappingFn, path.concat({\n            _key,\n            _index: idx\n          }));\n        }\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  }\n  if (isRecord(value)) {\n    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]));\n  }\n  return mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult) {\n      return value;\n    }\n    const {\n      mapping,\n      matchedPath\n    } = resolveMappingResult;\n    if (mapping.type !== \"value\") {\n      return value;\n    }\n    if (mapping.source.type !== \"documentValue\") {\n      return value;\n    }\n    const sourceDocument = csm.documents[mapping.source.document];\n    const sourcePath = csm.paths[mapping.source.path];\n    const matchPathSegments = parseJsonPath(matchedPath);\n    const sourcePathSegments = parseJsonPath(sourcePath);\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length);\n  }\n  return id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path\n  } = options;\n  if (!baseUrl) {\n    throw new Error(\"baseUrl is required\");\n  }\n  if (!path) {\n    throw new Error(\"path is required\");\n  }\n  if (!_id) {\n    throw new Error(\"id is required\");\n  }\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) {\n    throw new Error(\"baseUrl must not end with a slash\");\n  }\n  const workspace = _workspace === \"default\" ? void 0 : _workspace;\n  const tool = _tool === \"default\" ? void 0 : _tool;\n  const id = getPublishedId(_id);\n  const stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path;\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace) {\n    searchParams.set(\"workspace\", workspace);\n  }\n  if (tool) {\n    searchParams.set(\"tool\", tool);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  if (workspace) {\n    segments.push(workspace);\n  }\n  const routerParams = [\"mode=presentation\", \"id=\".concat(id), \"type=\".concat(type), \"path=\".concat(encodeURIComponent(stringifiedPath))];\n  if (tool) {\n    routerParams.push(\"tool=\".concat(tool));\n  }\n  segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams));\n  return segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl === \"string\" ? studioUrl : studioUrl.baseUrl;\n  if (baseUrl !== \"/\") {\n    baseUrl = baseUrl.replace(/\\/$/, \"\");\n  }\n  if (typeof studioUrl === \"string\") {\n    return {\n      baseUrl\n    };\n  }\n  return {\n    ...studioUrl,\n    baseUrl\n  };\n}\nconst filterDefault = ({\n  sourcePath,\n  value\n}) => {\n  if (isValidDate(value) || isValidURL(value)) {\n    return false;\n  }\n  const endPath = sourcePath.at(-1);\n  if (sourcePath.at(-2) === \"slug\" && endPath === \"current\") {\n    return false;\n  }\n  if (typeof endPath === \"string\" && endPath.startsWith(\"_\")) {\n    return false;\n  }\n  if (typeof endPath === \"number\" && sourcePath.at(-2) === \"marks\") {\n    return false;\n  }\n  if (endPath === \"href\" && typeof sourcePath.at(-2) === \"number\" && sourcePath.at(-3) === \"markDefs\") {\n    return false;\n  }\n  if (endPath === \"style\" || endPath === \"listItem\") {\n    return false;\n  }\n  if (sourcePath.some(path => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\")) {\n    return false;\n  }\n  if (typeof endPath === \"string\" && denylist.has(endPath)) {\n    return false;\n  }\n  return true;\n};\nconst denylist = /* @__PURE__ */new Set([\"color\", \"colour\", \"currency\", \"email\", \"format\", \"gid\", \"hex\", \"href\", \"hsl\", \"hsla\", \"icon\", \"id\", \"index\", \"key\", \"language\", \"layout\", \"link\", \"linkAction\", \"locale\", \"lqip\", \"page\", \"path\", \"ref\", \"rgb\", \"rgba\", \"route\", \"secret\", \"slug\", \"status\", \"tag\", \"template\", \"theme\", \"type\", \"unit\", \"url\", \"username\", \"variant\", \"website\"]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return false;\n  }\n  return true;\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const {\n    filter,\n    logger,\n    enabled\n  } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, \"[@sanity/client/stega]: \".concat(msg), {\n      result,\n      resultSourceMap,\n      config\n    });\n    throw new TypeError(msg);\n  }\n  if (!resultSourceMap) {\n    (_b = logger == null ? void 0 : logger.error) == null ? void 0 : _b.call(logger, \"[@sanity/client/stega]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    });\n    return result;\n  }\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    (_c = logger == null ? void 0 : logger.error) == null ? void 0 : _c.call(logger, \"[@sanity/client/stega]: \".concat(msg), {\n      result,\n      resultSourceMap,\n      config\n    });\n    throw new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  };\n  const resultWithStega = encodeIntoResult(result, resultSourceMap, ({\n    sourcePath,\n    sourceDocument,\n    resultPath,\n    value\n  }) => {\n    if ((typeof filter === \"function\" ? filter({\n      sourcePath,\n      resultPath,\n      filterDefault,\n      sourceDocument,\n      value\n    }) : filterDefault({\n      sourcePath,\n      resultPath,\n      filterDefault,\n      sourceDocument,\n      value\n    })) === false) {\n      if (logger) {\n        report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n          length: value.length\n        });\n      }\n      return value;\n    }\n    if (logger) {\n      report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: \"\".concat(value.slice(0, TRUNCATE_LENGTH)).concat(value.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n        length: value.length\n      });\n    }\n    const {\n      baseUrl,\n      workspace,\n      tool\n    } = resolveStudioBaseRoute(typeof config.studioUrl === \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl);\n    if (!baseUrl) return value;\n    const {\n      _id: id,\n      _type: type\n    } = sourceDocument;\n    return b(value, {\n      origin: \"sanity.io\",\n      href: createEditUrl({\n        baseUrl,\n        workspace,\n        tool,\n        id,\n        type,\n        path: sourcePath\n      })\n    },\n    // We use custom logic to determine if we should skip encoding\n    false);\n  });\n  if (logger) {\n    const isSkipping = report.skipped.length;\n    const isEncoding = report.encoded.length;\n    if (isSkipping || isEncoding) {\n      (_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _d(\"[@sanity/client/stega]: Encoding source map into result\");\n      (_e = logger.log) == null ? void 0 : _e.call(logger, \"[@sanity/client/stega]: Paths encoded: \".concat(report.encoded.length, \", skipped: \").concat(report.skipped.length));\n    }\n    if (report.encoded.length > 0) {\n      (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, \"[@sanity/client/stega]: Table of encoded paths\");\n      (_g = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _g(report.encoded);\n    }\n    if (report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */new Set();\n      for (const {\n        path\n      } of report.skipped) {\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      }\n      (_h = logger == null ? void 0 : logger.log) == null ? void 0 : _h.call(logger, \"[@sanity/client/stega]: List of skipped paths\", [...skipped.values()]);\n    }\n    if (isSkipping || isEncoding) {\n      (_i = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _i.call(logger);\n    }\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap: stegaEncodeSourceMap\n});\nexport { encodeIntoResult, stegaEncodeSourceMap, stegaEncodeSourceMap$1 };","map":{"version":3,"names":["reKeySegment","isKeySegment","segment","test","trim","toString","path","Array","isArray","Error","reduce","target","i","segmentType","concat","separator","_key","from","to","JSON","stringify","ESCAPE","UNESCAPE","jsonPath","map","escapedKey","replace","match","_index","join","parseJsonPath","parsed","parseRe","exec","key","m","push","parseInt","jsonPathToStudioPath","jsonPathToMappingPath","resolveMapping","resultPath","csm","mappings","resultMappingPath","mapping","matchedPath","pathSuffix","Object","entries","filter","startsWith","sort","key1","key2","length","substring","value","isRecord","walkMap","mappingFn","v","idx","fromEntries","k","encodeIntoResult","result","encoder","resolveMappingResult","type","source","sourceDocument","documents","document","sourcePath","paths","matchPathSegments","sourcePathSegments","fullSourceSegments","slice","DRAFTS_PREFIX","getPublishedId","id","createEditUrl","options","baseUrl","workspace","_workspace","tool","_tool","_id","endsWith","stringifiedPath","searchParams","URLSearchParams","set","segments","routerParams","encodeURIComponent","resolveStudioBaseRoute","studioUrl","filterDefault","isValidDate","isValidURL","endPath","at","some","denylist","has","Set","dateString","Boolean","Date","parse","url","URL","TRUNCATE_LENGTH","stegaEncodeSourceMap","resultSourceMap","config","_a","_b","_c","_d","_e","_f","_g","_h","_i","logger","enabled","msg","error","call","TypeError","report","encoded","skipped","resultWithStega","prettyPathForLogging","_type","b","origin","href","isSkipping","isEncoding","groupCollapsed","log","table","add","values","groupEnd"],"sources":["D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\studioPath.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\jsonPath.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\resolveMapping.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\isArray.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\isRecord.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\walkMap.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\stega\\encodeIntoResult.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\getPublishedId.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\createEditUrl.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\csm\\resolveEditInfo.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\stega\\filterDefault.ts","D:\\A Projects\\shareme-new\\shareme_frontend\\node_modules\\@sanity\\client\\src\\stega\\stegaEncodeSourceMap.ts"],"sourcesContent":["/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n","import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n","import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n","/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n","/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n","import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n","import {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport type {ContentSourceMap} from '../csm/types'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n","export const DRAFTS_PREFIX = 'drafts.'\n\n/** @internal */\nexport function getPublishedId(id: string): string {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length)\n  }\n\n  return id\n}\n","import {getPublishedId} from './getPublishedId'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  // eslint-disable-next-line no-warning-comments\n  // @TODO allow passing draft prefixed IDs, to better open the right perspective mode\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n","import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n","import type {FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath, value}) => {\n  // Skips encoding on URL or Date strings, similar to the `skip: 'auto'` parameter in vercelStegaCombine()\n  if (isValidDate(value) || isValidURL(value)) {\n    return false\n  }\n\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && endPath.startsWith('_')) {\n    return false\n  }\n\n  /**\n   * Best effort infer Portable Text paths that should not be encoded.\n   * Nothing is for certain, and the below implementation may cause paths that aren't Portable Text and otherwise be safe to encode to be skipped.\n   * However, that's ok as userland can always opt-in with the `encodeSourceMapAtPath` option and mark known safe paths as such, which will override this heuristic.\n   */\n  // If the path ends in marks[number] it's likely a PortableTextSpan: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#LL154C16-L154C16\n  if (typeof endPath === 'number' && sourcePath.at(-2) === 'marks') {\n    return false\n  }\n  // Or if it's [number].markDefs[number].href it's likely a PortableTextLink: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L163\n  if (\n    endPath === 'href' &&\n    typeof sourcePath.at(-2) === 'number' &&\n    sourcePath.at(-3) === 'markDefs'\n  ) {\n    return false\n  }\n  // Otherwise we have to deal with special properties of PortableTextBlock, and we can't confidently know if it's actually a `_type: 'block'` array item or not.\n  // All we know is that if it is indeed a block, and we encode the strings on these keys it'll for sure break the PortableText rendering and thus we skip encoding.\n  // https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L48-L58\n  if (endPath === 'style' || endPath === 'listItem') {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'href',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'secret',\n  'slug',\n  'status',\n  'tag',\n  'template',\n  'theme',\n  'type',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n\nfunction isValidDate(dateString: string) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false\n}\n\nfunction isValidURL(url: string) {\n  try {\n    new URL(url, url.startsWith('/') ? 'https://acme.com' : undefined)\n  } catch {\n    return false\n  }\n  return true\n}\n","import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {ContentSourceMap, ContentSourceMapParsedPath, InitializedStegaConfig} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n): Result {\n  const {filter, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client/stega]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {_id: id, _type: type} = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n          }),\n        },\n        // We use custom logic to determine if we should skip encoding\n        false,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.(\n        '[@sanity/client/stega]: Encoding source map into result',\n      )\n      logger.log?.(\n        `[@sanity/client/stega]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client/stega]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client/stega]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}