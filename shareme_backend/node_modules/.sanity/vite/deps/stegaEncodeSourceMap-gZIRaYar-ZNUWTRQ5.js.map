{
  "version": 3,
  "sources": ["../../../@sanity/client/src/csm/studioPath.ts", "../../../@sanity/client/src/csm/jsonPath.ts", "../../../@sanity/client/src/csm/resolveMapping.ts", "../../../@sanity/client/src/csm/isArray.ts", "../../../@sanity/client/src/csm/isRecord.ts", "../../../@sanity/client/src/csm/walkMap.ts", "../../../@sanity/client/src/stega/encodeIntoResult.ts", "../../../@sanity/client/src/csm/getPublishedId.ts", "../../../@sanity/client/src/csm/createEditUrl.ts", "../../../@sanity/client/src/csm/resolveEditInfo.ts", "../../../@sanity/client/src/stega/filterDefault.ts", "../../../@sanity/client/src/stega/stegaEncodeSourceMap.ts"],
  "sourcesContent": ["/** @alpha */\nexport type KeyedSegment = {_key: string}\n\n/** @alpha */\nexport type IndexTuple = [number | '', number | '']\n\n/** @alpha */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/** @alpha */\nexport type Path = PathSegment[]\n\nconst rePropName =\n  /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n/** @internal */\nexport const reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/\nconst reIndexTuple = /^\\d*:\\d*$/\n\n/** @internal */\nexport function isIndexSegment(segment: PathSegment): segment is number {\n  return typeof segment === 'number' || (typeof segment === 'string' && /^\\[\\d+\\]$/.test(segment))\n}\n\n/** @internal */\nexport function isKeySegment(segment: PathSegment): segment is KeyedSegment {\n  if (typeof segment === 'string') {\n    return reKeySegment.test(segment.trim())\n  }\n\n  return typeof segment === 'object' && '_key' in segment\n}\n\n/** @internal */\nexport function isIndexTuple(segment: PathSegment): segment is IndexTuple {\n  if (typeof segment === 'string' && reIndexTuple.test(segment)) {\n    return true\n  }\n\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false\n  }\n\n  const [from, to] = segment\n  return (typeof from === 'number' || from === '') && (typeof to === 'number' || to === '')\n}\n\n/** @internal */\nexport function get<Result = unknown, Fallback = unknown>(\n  obj: unknown,\n  path: Path | string,\n  defaultVal?: Fallback,\n): Result | typeof defaultVal {\n  const select = typeof path === 'string' ? fromString(path) : path\n  if (!Array.isArray(select)) {\n    throw new Error('Path must be an array or a string')\n  }\n\n  let acc: unknown | undefined = obj\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i]\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc[segment]\n    }\n\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal\n      }\n\n      acc = acc.find((item) => item._key === segment._key)\n    }\n\n    if (typeof segment === 'string') {\n      acc =\n        typeof acc === 'object' && acc !== null\n          ? ((acc as Record<string, unknown>)[segment] as Result)\n          : undefined\n    }\n\n    if (typeof acc === 'undefined') {\n      return defaultVal\n    }\n  }\n\n  return acc as Result\n}\n\n/** @alpha */\nexport function toString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    const segmentType = typeof segment\n    if (segmentType === 'number') {\n      return `${target}[${segment}]`\n    }\n\n    if (segmentType === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (Array.isArray(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\n/** @alpha */\nexport function fromString(path: string): Path {\n  if (typeof path !== 'string') {\n    throw new Error('Path is not a string')\n  }\n\n  const segments = path.match(rePropName)\n  if (!segments) {\n    throw new Error('Invalid path string')\n  }\n\n  return segments.map(parsePathSegment)\n}\n\nfunction parsePathSegment(segment: string): PathSegment {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment)\n  }\n\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment)\n  }\n\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment)\n  }\n\n  return segment\n}\n\nfunction parseIndexSegment(segment: string): PathSegment {\n  return Number(segment.replace(/[^\\d]/g, ''))\n}\n\nfunction parseKeySegment(segment: string): KeyedSegment {\n  const segments = segment.match(reKeySegment)\n  return {_key: segments![1]}\n}\n\nfunction parseIndexTupleSegment(segment: string): IndexTuple {\n  const [from, to] = segment.split(':').map((seg) => (seg === '' ? seg : Number(seg)))\n  return [from, to]\n}\n", "import * as studioPath from './studioPath'\nimport type {\n  ContentSourceMapParsedPath,\n  ContentSourceMapParsedPathKeyedSegment,\n  ContentSourceMapPaths,\n  Path,\n} from './types'\n\nconst ESCAPE: Record<string, string> = {\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  \"'\": \"\\\\'\",\n  '\\\\': '\\\\\\\\',\n}\n\nconst UNESCAPE: Record<string, string> = {\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t',\n  \"\\\\'\": \"'\",\n  '\\\\\\\\': '\\\\',\n}\n\n/**\n * @internal\n */\nexport function jsonPath(path: ContentSourceMapParsedPath): ContentSourceMapPaths[number] {\n  return `$${path\n    .map((segment) => {\n      if (typeof segment === 'string') {\n        const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `['${escapedKey}']`\n      }\n\n      if (typeof segment === 'number') {\n        return `[${segment}]`\n      }\n\n      if (segment._key !== '') {\n        const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n          return ESCAPE[match]\n        })\n        return `[?(@._key=='${escapedKey}')]`\n      }\n\n      return `[${segment._index}]`\n    })\n    .join('')}`\n}\n\n/**\n * @internal\n */\nexport function parseJsonPath(path: ContentSourceMapPaths[number]): ContentSourceMapParsedPath {\n  const parsed: ContentSourceMapParsedPath = []\n\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g\n  let match: RegExpExecArray | null\n\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== undefined) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push(key)\n      continue\n    }\n\n    if (match[2] !== undefined) {\n      parsed.push(parseInt(match[2], 10))\n      continue\n    }\n\n    if (match[3] !== undefined) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m]\n      })\n\n      parsed.push({\n        _key,\n        _index: -1,\n      })\n      continue\n    }\n  }\n\n  return parsed\n}\n\n/**\n * @internal\n */\nexport function jsonPathToStudioPath(path: ContentSourceMapParsedPath): Path {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._key !== '') {\n      return {_key: segment._key}\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\n/**\n * @internal\n */\nexport function studioPathToJsonPath(path: Path | string): ContentSourceMapParsedPath {\n  const parsedPath = typeof path === 'string' ? studioPath.fromString(path) : path\n\n  return parsedPath.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (Array.isArray(segment)) {\n      throw new Error(`IndexTuple segments aren't supported:${JSON.stringify(segment)}`)\n    }\n\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment\n    }\n\n    if (segment._key) {\n      return {_key: segment._key, _index: -1}\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n\nfunction isContentSourceMapParsedPathKeyedSegment(\n  segment: studioPath.PathSegment | ContentSourceMapParsedPath[number],\n): segment is ContentSourceMapParsedPathKeyedSegment {\n  return typeof segment === 'object' && '_key' in segment && '_index' in segment\n}\n\n/**\n * @internal\n */\nexport function jsonPathToMappingPath(path: ContentSourceMapParsedPath): (string | number)[] {\n  return path.map((segment) => {\n    if (typeof segment === 'string') {\n      return segment\n    }\n\n    if (typeof segment === 'number') {\n      return segment\n    }\n\n    if (segment._index !== -1) {\n      return segment._index\n    }\n\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`)\n  })\n}\n", "import {jsonPath, jsonPathToMappingPath} from './jsonPath'\nimport type {ContentSourceMap, ContentSourceMapMapping, ContentSourceMapParsedPath} from './types'\n\n/**\n * @internal\n */\nexport function resolveMapping(\n  resultPath: ContentSourceMapParsedPath,\n  csm?: ContentSourceMap,\n):\n  | {\n      mapping: ContentSourceMapMapping\n      matchedPath: string\n      pathSuffix: string\n    }\n  | undefined {\n  if (!csm?.mappings) {\n    return undefined\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath))\n\n  if (csm.mappings[resultMappingPath] !== undefined) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: '',\n    }\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultMappingPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultMappingPath.substring(matchedPath.length)\n  return {mapping, matchedPath, pathSuffix}\n}\n", "/** @internal */\nexport function isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n", "/** @internal */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n", "import {isArray} from './isArray'\nimport {isRecord} from './isRecord'\nimport type {ContentSourceMapParsedPath, WalkMapFn} from './types'\n\n/**\n * generic way to walk a nested object or array and apply a mapping function to each value\n * @internal\n */\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: ContentSourceMapParsedPath = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v['_key']\n        if (typeof _key === 'string') {\n          return walkMap(v, mappingFn, path.concat({_key, _index: idx}))\n        }\n      }\n\n      return walkMap(v, mappingFn, path.concat(idx))\n    })\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n", "import {parseJsonPath} from '../csm/jsonPath'\nimport {resolveMapping} from '../csm/resolveMapping'\nimport type {ContentSourceMap} from '../csm/types'\nimport {walkMap} from '../csm/walkMap'\nimport type {Encoder} from './types'\n\n/**\n * @internal\n */\nexport function encodeIntoResult<Result>(\n  result: Result,\n  csm: ContentSourceMap,\n  encoder: Encoder,\n): Result {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const {mapping, matchedPath} = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = csm.documents[mapping.source.document!]\n    const sourcePath = csm.paths[mapping.source.path]\n\n    const matchPathSegments = parseJsonPath(matchedPath)\n    const sourcePathSegments = parseJsonPath(sourcePath)\n    const fullSourceSegments = sourcePathSegments.concat(path.slice(matchPathSegments.length))\n\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value,\n    })\n  }) as Result\n}\n", "export const DRAFTS_PREFIX = 'drafts.'\n\n/** @internal */\nexport function getPublishedId(id: string): string {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length)\n  }\n\n  return id\n}\n", "import {getPublishedId} from './getPublishedId'\nimport {jsonPathToStudioPath} from './jsonPath'\nimport * as studioPath from './studioPath'\nimport type {CreateEditUrlOptions, EditIntentUrl, StudioBaseUrl} from './types'\n\n/** @internal */\nexport function createEditUrl(options: CreateEditUrlOptions): `${StudioBaseUrl}${EditIntentUrl}` {\n  const {\n    baseUrl,\n    workspace: _workspace = 'default',\n    tool: _tool = 'default',\n    id: _id,\n    type,\n    path,\n  } = options\n\n  if (!baseUrl) {\n    throw new Error('baseUrl is required')\n  }\n  if (!path) {\n    throw new Error('path is required')\n  }\n  if (!_id) {\n    throw new Error('id is required')\n  }\n  if (baseUrl !== '/' && baseUrl.endsWith('/')) {\n    throw new Error('baseUrl must not end with a slash')\n  }\n\n  const workspace = _workspace === 'default' ? undefined : _workspace\n  const tool = _tool === 'default' ? undefined : _tool\n  // eslint-disable-next-line no-warning-comments\n  // @TODO allow passing draft prefixed IDs, to better open the right perspective mode\n  const id = getPublishedId(_id)\n  const stringifiedPath = Array.isArray(path)\n    ? studioPath.toString(jsonPathToStudioPath(path))\n    : path\n\n  // eslint-disable-next-line no-warning-comments\n  // @TODO Using searchParams as a temporary workaround until `@sanity/overlays` can decode state from the path reliably\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath,\n  })\n  if (workspace) {\n    searchParams.set('workspace', workspace)\n  }\n  if (tool) {\n    searchParams.set('tool', tool)\n  }\n\n  const segments = [baseUrl === '/' ? '' : baseUrl]\n  if (workspace) {\n    segments.push(workspace)\n  }\n  const routerParams = [\n    'mode=presentation',\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`,\n  ]\n  if (tool) {\n    routerParams.push(`tool=${tool}`)\n  }\n  segments.push('intent', 'edit', `${routerParams.join(';')}?${searchParams}`)\n  return segments.join('/') as unknown as `${StudioBaseUrl}${EditIntentUrl}`\n}\n", "import {parseJsonPath} from './jsonPath'\nimport {resolveMapping} from './resolveMapping'\nimport type {\n  CreateEditUrlOptions,\n  ResolveEditInfoOptions,\n  StudioBaseRoute,\n  StudioBaseUrl,\n  StudioUrl,\n} from './types'\n\n/** @internal */\nexport function resolveEditInfo(options: ResolveEditInfoOptions): CreateEditUrlOptions | undefined {\n  const {resultSourceMap: csm, resultPath} = options\n  const {mapping, pathSuffix} = resolveMapping(resultPath, csm) || {}\n\n  if (!mapping) {\n    // console.warn('no mapping for path', { path: resultPath, sourceMap: csm })\n    return undefined\n  }\n\n  if (mapping.source.type === 'literal') {\n    return undefined\n  }\n\n  if (mapping.source.type === 'unknown') {\n    return undefined\n  }\n\n  const sourceDoc = csm.documents[mapping.source.document]\n  const sourcePath = csm.paths[mapping.source.path]\n\n  if (sourceDoc && sourcePath) {\n    const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n      typeof options.studioUrl === 'function' ? options.studioUrl(sourceDoc) : options.studioUrl,\n    )\n    if (!baseUrl) return undefined\n    const {_id, _type} = sourceDoc\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix),\n    } satisfies CreateEditUrlOptions\n  }\n\n  return undefined\n}\n\n/** @internal */\nexport function resolveStudioBaseRoute(studioUrl: StudioUrl): StudioBaseRoute {\n  let baseUrl: StudioBaseUrl = typeof studioUrl === 'string' ? studioUrl : studioUrl.baseUrl\n  if (baseUrl !== '/') {\n    baseUrl = baseUrl.replace(/\\/$/, '')\n  }\n  if (typeof studioUrl === 'string') {\n    return {baseUrl}\n  }\n  return {...studioUrl, baseUrl}\n}\n", "import type {FilterDefault} from './types'\n\nexport const filterDefault: FilterDefault = ({sourcePath, value}) => {\n  // Skips encoding on URL or Date strings, similar to the `skip: 'auto'` parameter in vercelStegaCombine()\n  if (isValidDate(value) || isValidURL(value)) {\n    return false\n  }\n\n  const endPath = sourcePath.at(-1)\n  // Never encode slugs\n  if (sourcePath.at(-2) === 'slug' && endPath === 'current') {\n    return false\n  }\n\n  // Skip underscored keys, needs better heuristics but it works for now\n  if (typeof endPath === 'string' && endPath.startsWith('_')) {\n    return false\n  }\n\n  /**\n   * Best effort infer Portable Text paths that should not be encoded.\n   * Nothing is for certain, and the below implementation may cause paths that aren't Portable Text and otherwise be safe to encode to be skipped.\n   * However, that's ok as userland can always opt-in with the `encodeSourceMapAtPath` option and mark known safe paths as such, which will override this heuristic.\n   */\n  // If the path ends in marks[number] it's likely a PortableTextSpan: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#LL154C16-L154C16\n  if (typeof endPath === 'number' && sourcePath.at(-2) === 'marks') {\n    return false\n  }\n  // Or if it's [number].markDefs[number].href it's likely a PortableTextLink: https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L163\n  if (\n    endPath === 'href' &&\n    typeof sourcePath.at(-2) === 'number' &&\n    sourcePath.at(-3) === 'markDefs'\n  ) {\n    return false\n  }\n  // Otherwise we have to deal with special properties of PortableTextBlock, and we can't confidently know if it's actually a `_type: 'block'` array item or not.\n  // All we know is that if it is indeed a block, and we encode the strings on these keys it'll for sure break the PortableText rendering and thus we skip encoding.\n  // https://github.com/portabletext/types/blob/e54eb24f136d8efd51a46c6a190e7c46e79b5380/src/portableText.ts#L48-L58\n  if (endPath === 'style' || endPath === 'listItem') {\n    return false\n  }\n\n  // Don't encode into anything that is suggested it'll render for SEO in meta tags\n  if (\n    sourcePath.some(\n      (path) => path === 'meta' || path === 'metadata' || path === 'openGraph' || path === 'seo',\n    )\n  ) {\n    return false\n  }\n\n  // Finally, we ignore a bunch of paths that are typically used for page building\n  if (typeof endPath === 'string' && denylist.has(endPath)) {\n    return false\n  }\n\n  return true\n}\n\nconst denylist = new Set([\n  'color',\n  'colour',\n  'currency',\n  'email',\n  'format',\n  'gid',\n  'hex',\n  'href',\n  'hsl',\n  'hsla',\n  'icon',\n  'id',\n  'index',\n  'key',\n  'language',\n  'layout',\n  'link',\n  'linkAction',\n  'locale',\n  'lqip',\n  'page',\n  'path',\n  'ref',\n  'rgb',\n  'rgba',\n  'route',\n  'secret',\n  'slug',\n  'status',\n  'tag',\n  'template',\n  'theme',\n  'type',\n  'unit',\n  'url',\n  'username',\n  'variant',\n  'website',\n])\n\nfunction isValidDate(dateString: string) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? Boolean(Date.parse(dateString)) : false\n}\n\nfunction isValidURL(url: string) {\n  try {\n    new URL(url, url.startsWith('/') ? 'https://acme.com' : undefined)\n  } catch {\n    return false\n  }\n  return true\n}\n", "import {vercelStegaCombine} from '@vercel/stega'\n\nimport {createEditUrl} from '../csm/createEditUrl'\nimport {jsonPathToStudioPath} from '../csm/jsonPath'\nimport {resolveStudioBaseRoute} from '../csm/resolveEditInfo'\nimport {reKeySegment, toString as studioPathToString} from '../csm/studioPath'\nimport {encodeIntoResult} from './encodeIntoResult'\nimport {filterDefault} from './filterDefault'\nimport {ContentSourceMap, ContentSourceMapParsedPath, InitializedStegaConfig} from './types'\n\nconst TRUNCATE_LENGTH = 20\n\n/**\n * Uses `@vercel/stega` to embed edit info JSON into strings in your query result.\n * The JSON payloads are added using invisible characters so they don't show up visually.\n * The edit info is generated from the Content Source Map (CSM) that is returned from Sanity for the query.\n * @public\n */\nexport function stegaEncodeSourceMap<Result = unknown>(\n  result: Result,\n  resultSourceMap: ContentSourceMap | undefined,\n  config: InitializedStegaConfig,\n): Result {\n  const {filter, logger, enabled} = config\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\"\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  if (!resultSourceMap) {\n    logger?.error?.('[@sanity/client/stega]: Missing Content Source Map from response body', {\n      result,\n      resultSourceMap,\n      config,\n    })\n    return result\n  }\n\n  if (!config.studioUrl) {\n    const msg = 'config.studioUrl must be defined'\n    logger?.error?.(`[@sanity/client/stega]: ${msg}`, {result, resultSourceMap, config})\n    throw new TypeError(msg)\n  }\n\n  const report: Record<'encoded' | 'skipped', {path: string; length: number; value: string}[]> = {\n    encoded: [],\n    skipped: [],\n  }\n\n  const resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({sourcePath, sourceDocument, resultPath, value}) => {\n      // Allow userland to control when to opt-out of encoding\n      if (\n        (typeof filter === 'function'\n          ? filter({sourcePath, resultPath, filterDefault, sourceDocument, value})\n          : filterDefault({sourcePath, resultPath, filterDefault, sourceDocument, value})) === false\n      ) {\n        if (logger) {\n          report.skipped.push({\n            path: prettyPathForLogging(sourcePath),\n            value: `${value.slice(0, TRUNCATE_LENGTH)}${\n              value.length > TRUNCATE_LENGTH ? '...' : ''\n            }`,\n            length: value.length,\n          })\n        }\n        return value\n      }\n\n      if (logger) {\n        report.encoded.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? '...' : ''}`,\n          length: value.length,\n        })\n      }\n\n      const {baseUrl, workspace, tool} = resolveStudioBaseRoute(\n        typeof config.studioUrl === 'function'\n          ? config.studioUrl(sourceDocument)\n          : config.studioUrl!,\n      )\n      if (!baseUrl) return value\n      const {_id: id, _type: type} = sourceDocument\n\n      return vercelStegaCombine(\n        value,\n        {\n          origin: 'sanity.io',\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n          }),\n        },\n        // We use custom logic to determine if we should skip encoding\n        false,\n      )\n    },\n  )\n\n  if (logger) {\n    const isSkipping = report.skipped.length\n    const isEncoding = report.encoded.length\n    if (isSkipping || isEncoding) {\n      ;(logger?.groupCollapsed || logger.log)?.(\n        '[@sanity/client/stega]: Encoding source map into result',\n      )\n      logger.log?.(\n        `[@sanity/client/stega]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`,\n      )\n    }\n    if (report.encoded.length > 0) {\n      logger?.log?.(`[@sanity/client/stega]: Table of encoded paths`)\n      ;(logger?.table || logger.log)?.(report.encoded)\n    }\n    if (report.skipped.length > 0) {\n      const skipped = new Set<string>()\n      for (const {path} of report.skipped) {\n        skipped.add(path.replace(reKeySegment, '0').replace(/\\[\\d+\\]/g, '[]'))\n      }\n      logger?.log?.(`[@sanity/client/stega]: List of skipped paths`, [...skipped.values()])\n    }\n\n    if (isSkipping || isEncoding) {\n      logger?.groupEnd?.()\n    }\n  }\n\n  return resultWithStega\n}\n\nfunction prettyPathForLogging(path: ContentSourceMapParsedPath): string {\n  return studioPathToString(jsonPathToStudioPath(path))\n}\n"],
  "mappings": "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",
  "names": ["studioPath.toString", "vercelStegaCombine", "studioPathToString"]
}
